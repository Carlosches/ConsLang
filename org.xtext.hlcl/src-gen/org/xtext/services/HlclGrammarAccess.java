/*
 * generated by Xtext 2.13.0
 */
package org.xtext.services;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import java.util.List;
import org.eclipse.xtext.Alternatives;
import org.eclipse.xtext.Assignment;
import org.eclipse.xtext.Grammar;
import org.eclipse.xtext.GrammarUtil;
import org.eclipse.xtext.Group;
import org.eclipse.xtext.Keyword;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.TerminalRule;
import org.eclipse.xtext.common.services.TerminalsGrammarAccess;
import org.eclipse.xtext.service.AbstractElementFinder.AbstractGrammarElementFinder;
import org.eclipse.xtext.service.GrammarProvider;

@Singleton
public class HlclGrammarAccess extends AbstractGrammarElementFinder {
	
	public class ModelElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.Hlcl.Model");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cVarsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cVarsVariablesParserRuleCall_0_0 = (RuleCall)cVarsAssignment_0.eContents().get(0);
		private final Assignment cConstraintsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cConstraintsConsExpParserRuleCall_1_0 = (RuleCall)cConstraintsAssignment_1.eContents().get(0);
		
		////genrates the Ecore model from the grammar
		//Model:
		//	vars+=Variables+ constraints+=ConsExp+;
		@Override public ParserRule getRule() { return rule; }
		
		//vars+=Variables+ constraints+=ConsExp+
		public Group getGroup() { return cGroup; }
		
		//vars+=Variables+
		public Assignment getVarsAssignment_0() { return cVarsAssignment_0; }
		
		//Variables
		public RuleCall getVarsVariablesParserRuleCall_0_0() { return cVarsVariablesParserRuleCall_0_0; }
		
		//constraints+=ConsExp+
		public Assignment getConstraintsAssignment_1() { return cConstraintsAssignment_1; }
		
		//ConsExp
		public RuleCall getConstraintsConsExpParserRuleCall_1_0() { return cConstraintsConsExpParserRuleCall_1_0; }
	}
	public class VariablesElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.Hlcl.Variables");
		private final Assignment cVarsAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cVarsVariableParserRuleCall_0 = (RuleCall)cVarsAssignment.eContents().get(0);
		
		//Variables:
		//	vars+=Variable;
		@Override public ParserRule getRule() { return rule; }
		
		//vars+=Variable
		public Assignment getVarsAssignment() { return cVarsAssignment; }
		
		//Variable
		public RuleCall getVarsVariableParserRuleCall_0() { return cVarsVariableParserRuleCall_0; }
	}
	public class VariableElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.Hlcl.Variable");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cVarKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cInKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cDomAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cDomDomainParserRuleCall_3_0 = (RuleCall)cDomAssignment_3.eContents().get(0);
		
		//Variable:
		//	'var' name=ID 'in' dom=Domain;
		@Override public ParserRule getRule() { return rule; }
		
		//'var' name=ID 'in' dom=Domain
		public Group getGroup() { return cGroup; }
		
		//'var'
		public Keyword getVarKeyword_0() { return cVarKeyword_0; }
		
		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }
		
		//'in'
		public Keyword getInKeyword_2() { return cInKeyword_2; }
		
		//dom=Domain
		public Assignment getDomAssignment_3() { return cDomAssignment_3; }
		
		//Domain
		public RuleCall getDomDomainParserRuleCall_3_0() { return cDomDomainParserRuleCall_3_0; }
	}
	public class DomainElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.Hlcl.Domain");
		private final Assignment cDomAssignment = (Assignment)rule.eContents().get(1);
		private final Alternatives cDomAlternatives_0 = (Alternatives)cDomAssignment.eContents().get(0);
		private final RuleCall cDomRangeDomainParserRuleCall_0_0 = (RuleCall)cDomAlternatives_0.eContents().get(0);
		private final RuleCall cDomSetDomainParserRuleCall_0_1 = (RuleCall)cDomAlternatives_0.eContents().get(1);
		
		//Domain:
		//	dom=(RangeDomain | SetDomain);
		@Override public ParserRule getRule() { return rule; }
		
		//dom=(RangeDomain | SetDomain)
		public Assignment getDomAssignment() { return cDomAssignment; }
		
		//(RangeDomain | SetDomain)
		public Alternatives getDomAlternatives_0() { return cDomAlternatives_0; }
		
		//RangeDomain
		public RuleCall getDomRangeDomainParserRuleCall_0_0() { return cDomRangeDomainParserRuleCall_0_0; }
		
		//SetDomain
		public RuleCall getDomSetDomainParserRuleCall_0_1() { return cDomSetDomainParserRuleCall_0_1; }
	}
	public class RangeDomainElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.Hlcl.RangeDomain");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cStartAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cStartINTTerminalRuleCall_0_0 = (RuleCall)cStartAssignment_0.eContents().get(0);
		private final Keyword cFullStopFullStopKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cEndAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cEndINTTerminalRuleCall_2_0 = (RuleCall)cEndAssignment_2.eContents().get(0);
		
		//RangeDomain:
		//	start=INT '..' end=INT;
		@Override public ParserRule getRule() { return rule; }
		
		//start=INT '..' end=INT
		public Group getGroup() { return cGroup; }
		
		//start=INT
		public Assignment getStartAssignment_0() { return cStartAssignment_0; }
		
		//INT
		public RuleCall getStartINTTerminalRuleCall_0_0() { return cStartINTTerminalRuleCall_0_0; }
		
		//'..'
		public Keyword getFullStopFullStopKeyword_1() { return cFullStopFullStopKeyword_1; }
		
		//end=INT
		public Assignment getEndAssignment_2() { return cEndAssignment_2; }
		
		//INT
		public RuleCall getEndINTTerminalRuleCall_2_0() { return cEndINTTerminalRuleCall_2_0; }
	}
	public class SetDomainElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.Hlcl.SetDomain");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftSquareBracketKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Assignment cListAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final RuleCall cListINTTerminalRuleCall_1_0_0 = (RuleCall)cListAssignment_1_0.eContents().get(0);
		private final Group cGroup_1_1 = (Group)cGroup_1.eContents().get(1);
		private final Keyword cCommaKeyword_1_1_0 = (Keyword)cGroup_1_1.eContents().get(0);
		private final RuleCall cINTTerminalRuleCall_1_1_1 = (RuleCall)cGroup_1_1.eContents().get(1);
		private final Keyword cRightSquareBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//SetDomain:
		//	'[' (list=INT (',' INT)+) ']';
		@Override public ParserRule getRule() { return rule; }
		
		//'[' (list=INT (',' INT)+) ']'
		public Group getGroup() { return cGroup; }
		
		//'['
		public Keyword getLeftSquareBracketKeyword_0() { return cLeftSquareBracketKeyword_0; }
		
		//list=INT (',' INT)+
		public Group getGroup_1() { return cGroup_1; }
		
		//list=INT
		public Assignment getListAssignment_1_0() { return cListAssignment_1_0; }
		
		//INT
		public RuleCall getListINTTerminalRuleCall_1_0_0() { return cListINTTerminalRuleCall_1_0_0; }
		
		//(',' INT)+
		public Group getGroup_1_1() { return cGroup_1_1; }
		
		//','
		public Keyword getCommaKeyword_1_1_0() { return cCommaKeyword_1_1_0; }
		
		//INT
		public RuleCall getINTTerminalRuleCall_1_1_1() { return cINTTerminalRuleCall_1_1_1; }
		
		//']'
		public Keyword getRightSquareBracketKeyword_2() { return cRightSquareBracketKeyword_2; }
	}
	public class ConsExpElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.Hlcl.ConsExp");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cBooleanExpParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cIntExpParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//ConsExp:
		//	BooleanExp | IntExp;
		@Override public ParserRule getRule() { return rule; }
		
		//BooleanExp | IntExp
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//BooleanExp
		public RuleCall getBooleanExpParserRuleCall_0() { return cBooleanExpParserRuleCall_0; }
		
		//IntExp
		public RuleCall getIntExpParserRuleCall_1() { return cIntExpParserRuleCall_1; }
	}
	public class BooleanExpElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.Hlcl.BooleanExp");
		private final Keyword cBooleanExpressionKeyword = (Keyword)rule.eContents().get(1);
		
		//BooleanExp:
		//	'Boolean expression';
		@Override public ParserRule getRule() { return rule; }
		
		//'Boolean expression'
		public Keyword getBooleanExpressionKeyword() { return cBooleanExpressionKeyword; }
	}
	public class IntExpElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.Hlcl.IntExp");
		private final Keyword cIntExpressionKeyword = (Keyword)rule.eContents().get(1);
		
		//IntExp:
		//	'Int expression';
		@Override public ParserRule getRule() { return rule; }
		
		//'Int expression'
		public Keyword getIntExpressionKeyword() { return cIntExpressionKeyword; }
	}
	
	
	private final ModelElements pModel;
	private final VariablesElements pVariables;
	private final VariableElements pVariable;
	private final DomainElements pDomain;
	private final RangeDomainElements pRangeDomain;
	private final SetDomainElements pSetDomain;
	private final ConsExpElements pConsExp;
	private final BooleanExpElements pBooleanExp;
	private final IntExpElements pIntExp;
	
	private final Grammar grammar;
	
	private final TerminalsGrammarAccess gaTerminals;

	@Inject
	public HlclGrammarAccess(GrammarProvider grammarProvider,
			TerminalsGrammarAccess gaTerminals) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaTerminals = gaTerminals;
		this.pModel = new ModelElements();
		this.pVariables = new VariablesElements();
		this.pVariable = new VariableElements();
		this.pDomain = new DomainElements();
		this.pRangeDomain = new RangeDomainElements();
		this.pSetDomain = new SetDomainElements();
		this.pConsExp = new ConsExpElements();
		this.pBooleanExp = new BooleanExpElements();
		this.pIntExp = new IntExpElements();
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("org.xtext.Hlcl".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	
	
	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	////genrates the Ecore model from the grammar
	//Model:
	//	vars+=Variables+ constraints+=ConsExp+;
	public ModelElements getModelAccess() {
		return pModel;
	}
	
	public ParserRule getModelRule() {
		return getModelAccess().getRule();
	}
	
	//Variables:
	//	vars+=Variable;
	public VariablesElements getVariablesAccess() {
		return pVariables;
	}
	
	public ParserRule getVariablesRule() {
		return getVariablesAccess().getRule();
	}
	
	//Variable:
	//	'var' name=ID 'in' dom=Domain;
	public VariableElements getVariableAccess() {
		return pVariable;
	}
	
	public ParserRule getVariableRule() {
		return getVariableAccess().getRule();
	}
	
	//Domain:
	//	dom=(RangeDomain | SetDomain);
	public DomainElements getDomainAccess() {
		return pDomain;
	}
	
	public ParserRule getDomainRule() {
		return getDomainAccess().getRule();
	}
	
	//RangeDomain:
	//	start=INT '..' end=INT;
	public RangeDomainElements getRangeDomainAccess() {
		return pRangeDomain;
	}
	
	public ParserRule getRangeDomainRule() {
		return getRangeDomainAccess().getRule();
	}
	
	//SetDomain:
	//	'[' (list=INT (',' INT)+) ']';
	public SetDomainElements getSetDomainAccess() {
		return pSetDomain;
	}
	
	public ParserRule getSetDomainRule() {
		return getSetDomainAccess().getRule();
	}
	
	//ConsExp:
	//	BooleanExp | IntExp;
	public ConsExpElements getConsExpAccess() {
		return pConsExp;
	}
	
	public ParserRule getConsExpRule() {
		return getConsExpAccess().getRule();
	}
	
	//BooleanExp:
	//	'Boolean expression';
	public BooleanExpElements getBooleanExpAccess() {
		return pBooleanExp;
	}
	
	public ParserRule getBooleanExpRule() {
		return getBooleanExpAccess().getRule();
	}
	
	//IntExp:
	//	'Int expression';
	public IntExpElements getIntExpAccess() {
		return pIntExp;
	}
	
	public ParserRule getIntExpRule() {
		return getIntExpAccess().getRule();
	}
	
	//terminal ID:
	//	'^'? ('a'..'z' | 'A'..'Z' | '_') ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	}
	
	//terminal INT returns ecore::EInt:
	//	'0'..'9'+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	}
	
	//terminal STRING:
	//	'"' ('\\' . | !('\\' | '"'))* '"' |
	//	"'" ('\\' . | !('\\' | "'"))* "'";
	public TerminalRule getSTRINGRule() {
		return gaTerminals.getSTRINGRule();
	}
	
	//terminal ML_COMMENT:
	//	'/*'->'*/';
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	}
	
	//terminal SL_COMMENT:
	//	'//' !('\n' | '\r')* ('\r'? '\n')?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	}
	
	//terminal WS:
	//	' ' | '\t' | '\r' | '\n'+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	}
	
	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	}
}
